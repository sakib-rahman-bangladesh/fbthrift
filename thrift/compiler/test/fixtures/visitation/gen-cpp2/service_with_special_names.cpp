/**
 * Autogenerated by Thrift for src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/compiler/test/fixtures/visitation/gen-cpp2/service_with_special_names.h"
#include "thrift/compiler/test/fixtures/visitation/gen-cpp2/service_with_special_names.tcc"
#include "thrift/compiler/test/fixtures/visitation/gen-cpp2/module_metadata.h"
#include <thrift/lib/cpp2/gen/service_cpp.h>

namespace test_cpp2 { namespace cpp_reflection {
std::unique_ptr<apache::thrift::AsyncProcessor> service_with_special_namesSvIf::getProcessor() {
  return std::make_unique<service_with_special_namesAsyncProcessor>(this);
}


::std::int32_t service_with_special_namesSvIf::get() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("get");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_get() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_get.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return get();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_get() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_get.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_get(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_get(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_get.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_get.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_get();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_get(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(get());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_get();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::getter() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("getter");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_getter() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_getter.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return getter();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_getter() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_getter.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_getter(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_getter(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_getter.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_getter.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_getter();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_getter(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(getter());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_getter();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::lists() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("lists");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_lists() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_lists.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return lists();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_lists() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_lists.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_lists(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_lists(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_lists.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_lists.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_lists();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_lists(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(lists());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_lists();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::maps() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("maps");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_maps() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_maps.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return maps();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_maps() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_maps.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_maps(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_maps(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_maps.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_maps.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_maps();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_maps(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(maps());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_maps();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::name() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("name");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_name() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_name.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return name();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_name() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_name.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_name(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_name(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_name.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_name.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_name();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_name(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(name());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_name();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::name_to_value() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("name_to_value");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_name_to_value() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_name_to_value.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return name_to_value();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_name_to_value() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_name_to_value.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_name_to_value(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_name_to_value(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_name_to_value.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_name_to_value.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_name_to_value();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_name_to_value(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(name_to_value());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_name_to_value();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::names() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("names");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_names() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_names.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return names();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_names() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_names.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_names(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_names(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_names.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_names.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_names();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_names(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(names());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_names();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::prefix_tree() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("prefix_tree");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_prefix_tree() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_prefix_tree.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return prefix_tree();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_prefix_tree() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_prefix_tree.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_prefix_tree(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_prefix_tree(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_prefix_tree.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_prefix_tree.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_prefix_tree();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_prefix_tree(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(prefix_tree());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_prefix_tree();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::sets() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("sets");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_sets() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_sets.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return sets();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_sets() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_sets.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_sets(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_sets(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_sets.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_sets.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_sets();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_sets(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(sets());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_sets();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::setter() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("setter");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_setter() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_setter.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return setter();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_setter() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_setter.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_setter(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_setter(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_setter.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_setter.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_setter();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_setter(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(setter());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_setter();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::str() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("str");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_str() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_str.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return str();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_str() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_str.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_str(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_str(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_str.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_str.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_str();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_str(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(str());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_str();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::strings() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("strings");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_strings() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_strings.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return strings();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_strings() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_strings.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_strings(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_strings(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_strings.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_strings.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_strings();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_strings(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(strings());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_strings();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::type() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("type");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_type() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_type.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return type();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_type() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_type.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_type(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_type(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_type.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_type.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_type();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_type(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(type());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_type();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::value() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("value");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_value() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_value.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return value();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_value() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_value.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_value(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_value(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_value.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_value.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_value();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_value(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(value());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_value();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::value_to_name() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("value_to_name");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_value_to_name() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_value_to_name.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return value_to_name();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_value_to_name() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_value_to_name.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_value_to_name(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_value_to_name(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_value_to_name.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_value_to_name.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_value_to_name();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_value_to_name(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(value_to_name());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_value_to_name();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::values() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("values");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_values() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_values.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return values();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_values() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_values.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_values(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_values(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_values.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_values.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_values();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_values(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(values());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_values();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::id() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("id");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_id() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_id.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return id();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_id() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_id.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_id(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_id(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_id.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_id.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_id();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_id(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(id());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_id();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::ids() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("ids");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_ids() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_ids.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return ids();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_ids() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_ids.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_ids(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_ids(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_ids.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_ids.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_ids();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_ids(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(ids());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_ids();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::descriptor() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("descriptor");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_descriptor() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_descriptor.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return descriptor();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_descriptor() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_descriptor.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_descriptor(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_descriptor(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_descriptor.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_descriptor.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_descriptor();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_descriptor(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(descriptor());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_descriptor();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::descriptors() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("descriptors");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_descriptors() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_descriptors.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return descriptors();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_descriptors() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_descriptors.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_descriptors(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_descriptors(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_descriptors.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_descriptors.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_descriptors();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_descriptors(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(descriptors());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_descriptors();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::key() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("key");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_key() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_key.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return key();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_key() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_key.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_key(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_key(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_key.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_key.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_key();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_key(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(key());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_key();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::keys() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("keys");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_keys() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_keys.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return keys();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_keys() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_keys.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_keys(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_keys(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_keys.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_keys.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_keys();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_keys(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(keys());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_keys();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::annotation() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("annotation");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_annotation() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_annotation.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return annotation();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_annotation() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_annotation.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_annotation(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_annotation(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_annotation.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_annotation.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_annotation();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_annotation(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(annotation());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_annotation();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::annotations() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("annotations");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_annotations() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_annotations.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return annotations();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_annotations() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_annotations.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_annotations(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_annotations(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_annotations.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_annotations.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_annotations();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_annotations(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(annotations());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_annotations();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::member() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("member");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_member() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_member.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return member();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_member() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_member.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_member(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_member(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_member.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_member.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_member();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_member(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(member());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_member();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::members() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("members");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_members() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_members.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return members();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_members() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_members.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_members(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_members(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_members.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_members.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_members();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_members(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(members());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_members();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::field() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("field");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_field() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_field.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return field();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_field() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_field.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_field(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_field(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_field.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_field.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_field();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_field(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(field());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_field();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvIf::fields() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("fields");
}

folly::SemiFuture<::std::int32_t> service_with_special_namesSvIf::semifuture_fields() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_fields.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return apache::thrift::detail::si::semifuture([&] {
    return fields();
  });
}

folly::Future<::std::int32_t> service_with_special_namesSvIf::future_fields() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_fields.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  auto ka = getThreadManager()->getKeepAlive(getRequestContext()->getRequestExecutionScope(), apache::thrift::concurrency::ThreadManager::Source::INTERNAL);
  return apache::thrift::detail::si::future(semifuture_fields(), std::move(ka));
}

void service_with_special_namesSvIf::async_tm_fields(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we set that up
  // for all cases.
  apache::thrift::detail::si::async_tm_prep(this, callback.get());
  switch (__fbthrift_invocation_fields.load(std::memory_order_relaxed)) {
    case apache::thrift::detail::si::InvocationType::AsyncTm:
    {
      auto expected{apache::thrift::detail::si::InvocationType::AsyncTm};
      __fbthrift_invocation_fields.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_fields();
      });
      return;
    }
    case apache::thrift::detail::si::InvocationType::SemiFuture:
    {
      apache::thrift::detail::si::async_tm_semifuture(std::move(callback), [&] {
        return semifuture_fields(); });
      return;
    }
    case apache::thrift::detail::si::InvocationType::Sync:
    {
      try {
        callback->result(fields());
      } catch (...) {
        callback->exception(std::current_exception());
      }
      return;
    }
    case apache::thrift::detail::si::InvocationType::Future:
    {
      apache::thrift::detail::si::async_tm_future(std::move(callback), [&] {
        return future_fields();
      });
      return;
    }
    default:
    {
      folly::assume_unreachable();
    }
  }
}

::std::int32_t service_with_special_namesSvNull::get() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::getter() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::lists() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::maps() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::name() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::name_to_value() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::names() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::prefix_tree() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::sets() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::setter() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::str() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::strings() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::type() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::value() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::value_to_name() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::values() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::id() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::ids() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::descriptor() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::descriptors() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::key() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::keys() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::annotation() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::annotations() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::member() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::members() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::field() {
  return 0;
}

::std::int32_t service_with_special_namesSvNull::fields() {
  return 0;
}



const char* service_with_special_namesAsyncProcessor::getServiceName() {
  return "service_with_special_names";
}

void service_with_special_namesAsyncProcessor::getServiceMetadata(apache::thrift::metadata::ThriftServiceMetadataResponse& response) {
  ::apache::thrift::detail::md::ServiceMetadata<service_with_special_namesSvIf>::gen(*response.metadata_ref(), *response.context_ref());
}

void service_with_special_namesAsyncProcessor::processSerializedCompressedRequest(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, apache::thrift::protocol::PROTOCOL_TYPES protType, apache::thrift::Cpp2RequestContext* context, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  apache::thrift::detail::ap::process(this, std::move(req), std::move(serializedRequest), protType, context, eb, tm);
}

std::shared_ptr<folly::RequestContext> service_with_special_namesAsyncProcessor::getBaseContextForRequest() {
  return iface_->getBaseContextForRequest();
}

const service_with_special_namesAsyncProcessor::ProcessMap& service_with_special_namesAsyncProcessor::getBinaryProtocolProcessMap() {
  return binaryProcessMap_;
}

const service_with_special_namesAsyncProcessor::ProcessMap service_with_special_namesAsyncProcessor::binaryProcessMap_ {
  {"get", &service_with_special_namesAsyncProcessor::setUpAndProcess_get<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"getter", &service_with_special_namesAsyncProcessor::setUpAndProcess_getter<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"lists", &service_with_special_namesAsyncProcessor::setUpAndProcess_lists<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"maps", &service_with_special_namesAsyncProcessor::setUpAndProcess_maps<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"name", &service_with_special_namesAsyncProcessor::setUpAndProcess_name<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"name_to_value", &service_with_special_namesAsyncProcessor::setUpAndProcess_name_to_value<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"names", &service_with_special_namesAsyncProcessor::setUpAndProcess_names<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"prefix_tree", &service_with_special_namesAsyncProcessor::setUpAndProcess_prefix_tree<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"sets", &service_with_special_namesAsyncProcessor::setUpAndProcess_sets<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"setter", &service_with_special_namesAsyncProcessor::setUpAndProcess_setter<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"str", &service_with_special_namesAsyncProcessor::setUpAndProcess_str<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"strings", &service_with_special_namesAsyncProcessor::setUpAndProcess_strings<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"type", &service_with_special_namesAsyncProcessor::setUpAndProcess_type<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"value", &service_with_special_namesAsyncProcessor::setUpAndProcess_value<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"value_to_name", &service_with_special_namesAsyncProcessor::setUpAndProcess_value_to_name<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"values", &service_with_special_namesAsyncProcessor::setUpAndProcess_values<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"id", &service_with_special_namesAsyncProcessor::setUpAndProcess_id<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"ids", &service_with_special_namesAsyncProcessor::setUpAndProcess_ids<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"descriptor", &service_with_special_namesAsyncProcessor::setUpAndProcess_descriptor<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"descriptors", &service_with_special_namesAsyncProcessor::setUpAndProcess_descriptors<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"key", &service_with_special_namesAsyncProcessor::setUpAndProcess_key<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"keys", &service_with_special_namesAsyncProcessor::setUpAndProcess_keys<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"annotation", &service_with_special_namesAsyncProcessor::setUpAndProcess_annotation<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"annotations", &service_with_special_namesAsyncProcessor::setUpAndProcess_annotations<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"member", &service_with_special_namesAsyncProcessor::setUpAndProcess_member<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"members", &service_with_special_namesAsyncProcessor::setUpAndProcess_members<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"field", &service_with_special_namesAsyncProcessor::setUpAndProcess_field<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
  {"fields", &service_with_special_namesAsyncProcessor::setUpAndProcess_fields<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>},
};

const service_with_special_namesAsyncProcessor::ProcessMap& service_with_special_namesAsyncProcessor::getCompactProtocolProcessMap() {
  return compactProcessMap_;
}

const service_with_special_namesAsyncProcessor::ProcessMap service_with_special_namesAsyncProcessor::compactProcessMap_ {
  {"get", &service_with_special_namesAsyncProcessor::setUpAndProcess_get<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"getter", &service_with_special_namesAsyncProcessor::setUpAndProcess_getter<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"lists", &service_with_special_namesAsyncProcessor::setUpAndProcess_lists<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"maps", &service_with_special_namesAsyncProcessor::setUpAndProcess_maps<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"name", &service_with_special_namesAsyncProcessor::setUpAndProcess_name<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"name_to_value", &service_with_special_namesAsyncProcessor::setUpAndProcess_name_to_value<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"names", &service_with_special_namesAsyncProcessor::setUpAndProcess_names<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"prefix_tree", &service_with_special_namesAsyncProcessor::setUpAndProcess_prefix_tree<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"sets", &service_with_special_namesAsyncProcessor::setUpAndProcess_sets<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"setter", &service_with_special_namesAsyncProcessor::setUpAndProcess_setter<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"str", &service_with_special_namesAsyncProcessor::setUpAndProcess_str<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"strings", &service_with_special_namesAsyncProcessor::setUpAndProcess_strings<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"type", &service_with_special_namesAsyncProcessor::setUpAndProcess_type<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"value", &service_with_special_namesAsyncProcessor::setUpAndProcess_value<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"value_to_name", &service_with_special_namesAsyncProcessor::setUpAndProcess_value_to_name<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"values", &service_with_special_namesAsyncProcessor::setUpAndProcess_values<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"id", &service_with_special_namesAsyncProcessor::setUpAndProcess_id<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"ids", &service_with_special_namesAsyncProcessor::setUpAndProcess_ids<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"descriptor", &service_with_special_namesAsyncProcessor::setUpAndProcess_descriptor<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"descriptors", &service_with_special_namesAsyncProcessor::setUpAndProcess_descriptors<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"key", &service_with_special_namesAsyncProcessor::setUpAndProcess_key<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"keys", &service_with_special_namesAsyncProcessor::setUpAndProcess_keys<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"annotation", &service_with_special_namesAsyncProcessor::setUpAndProcess_annotation<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"annotations", &service_with_special_namesAsyncProcessor::setUpAndProcess_annotations<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"member", &service_with_special_namesAsyncProcessor::setUpAndProcess_member<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"members", &service_with_special_namesAsyncProcessor::setUpAndProcess_members<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"field", &service_with_special_namesAsyncProcessor::setUpAndProcess_field<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
  {"fields", &service_with_special_namesAsyncProcessor::setUpAndProcess_fields<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>},
};

}} // test_cpp2::cpp_reflection
